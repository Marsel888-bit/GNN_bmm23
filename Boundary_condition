import os
import os.path as osp
import json
import shutil
import pprint
import numpy as np
from matplotlib import pyplot as plt
from scipy.integrate import quad
from scipy.interpolate import make_interp_spline
import pandas as pd
from google.colab import drive
drive.mount('drive')
import warnings
warnings.filterwarnings("ignore")
from IPython.display import clear_output


def generate_points (n):
  x = np.linspace(-3, 3, n)
  y = np.random.uniform(0.25, 0.6, n)
  y[0] = 0.0
  y[-1] = 0.0
  return x, y


def get_cross_section (n, num_of_iters, out_dir):

  os.makedirs(out_dir, exist_ok=True)
  df = pd.DataFrame()
  x, y = generate_points(n)
  x_y_spline = make_interp_spline(x, y)
  x = np.linspace(x.min(), x.max(), 100)
  df['x'] = x

  for i in range(1, num_of_iters):
    x_iter, y_iter = generate_points(n)
    x_y_spline = make_interp_spline(x_iter, y_iter)
    X_ = np.linspace(x_iter.min(), x_iter.max(), 100)
    Y_ = x_y_spline(X_)
    for j in range(1, len(Y_)-1):
      noise = np.random.normal(0, 0.01, 1)
      Y_[j] = Y_[j] + noise 
    Y_ = np.array([elem * (2 / np.max(Y_)) for elem in list(Y_)])
    df[f'{i}'] = Y_
    plt.plot(X_, Y_)
    plt.title(f"Plot Smooth Curve of cross section number {i}")
    plt.xlabel("y")
    plt.ylabel("u")
    plt.show()
    plt.tight_layout()
    plt.savefig(os.path.join(out_dir, f'cross_section{i}.png'))
    display(plt.gcf())
    clear_output(wait=True)
  df.to_csv('data.csv', header=False, index=False)
  !cp data.csv "drive/My Drive/"
  return df

out_dir = 'out'
df = get_cross_section(15, 100, out_dir)


def integrate_cos(x, k):
    return np.cos(np.pi * x * k / 6) * x_y_spline(x)

def integrate_sin(x, k):
    return np.sin(np.pi * x * k / 6) * x_y_spline(x)


def Fourier_construct (x, spline):

  k = np.arange(1, x.shape[0] + 1)
  a_0 = (1 / 3) * quad(spline, -3, 3)[0]
  a_k = (1 / 3) * np.array([quad(integrate_cos, -3, 3, args=(ki,))[0] for ki in k])
  b_k = (1 / 3) * np.array([quad(integrate_sin, -3, 3, args=(ki,))[0] for ki in k])
  res = list(np.concatenate([a_k, b_k], axis = 0))
  res.insert(0, a_0)
  return np.array([res]), a_k, b_k


res, a_k, b_k = Fourier_construct(x, x_y_spline)


def Fourier_series(x, res, a_k, b_k):

    k = np.arange(1, 101)
    series = res[0][0]/2 + np.sum(a_k.reshape(-1, 1) * np.cos(2 * np.pi * x * k.reshape(-1, 1) / 6) + b_k.reshape(-1, 1) * np.sin(2 * np.pi * x * k.reshape(-1, 1) / 6), axis=0)
    return series.flatten()

series = Fourier_series(x, res, a_k, b_k)


x_values = x
y_interp = x_y_spline(x_values)
y_fourier = Fourier_series(x_values, res, a_k, b_k)


plt.plot(x_values, y_interp, 'r', label='Интерполируемая функция')
plt.plot(x_values, y_fourier, 'b--', label='Сумма ряда Фурье (N=5)')
#plt.scatter(x, y, color='black', label='Табличные данные')
plt.legend()
plt.xlabel('X')
plt.ylabel('Y')
plt.title('График интерполируемой функции и ряда Фурье')
plt.grid(True)
plt.show()
